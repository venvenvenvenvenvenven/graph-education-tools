<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Образовательная среда для графов</title>

    <style type="text/css">
      body,
      select {
        font: 10pt sans;
      }
      #mynetwork1 {
        position: relative;
        width: 45%;
        height: 600px;
        border: 1px solid lightgray;
        float: left;
      }
      #mynetwork2 {
        position: relative;
        width: 45%;
        height: 600px;
        border: 1px solid lightgray;
        float: right;
      }
      table.legend_table {
        font-size: 11px;
        border-width: 1px;
        border-color: #d3d3d3;
        border-style: solid;
      }
      table.legend_table,
      td {
        border-width: 1px;
        border-color: #d3d3d3;
        border-style: solid;
        padding: 2px;
      }
      div.table_content {
        width: 80px;
        text-align: center;
      }
      div.table_description {
        width: 100px;
      }

      #operation {
        font-size: 28px;
      }
      textarea {
        width: 75%;
        height: 200px;
        padding: 10px;
        left: 50%;
        margin-top: 20px;
      }
      
    </style>

    <script
      type="text/javascript"
      src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"
    ></script>

    <script
      type="text/javascript"
      src="https://unpkg.com/vis-data@7.1.9/standalone/umd/vis-data.js"
    ></script>

    <script
      type="text/javascript"
      src="https://unpkg.com/alea@1.0.0/alea.js"
    ></script>

    <script type="text/javascript" src="randomgen.js"></script>

    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/underscore@1.13.6/underscore-umd-min.js"
    ></script>

    <script type="text/javascript">
      var nodes = null;
      var edges = null;
      var network1 = null;
      var data = randomgen(6);
      var lastNodeId = 5

      // создание дополнения
      function compGraph(data){
        let nodes = data.nodes.get();
        let ogEdges = data.edges.get()
        let edges = [];
        edgesId = 0;
        for(let i = 0; i < nodes.length; i++){
            for(let k = 0; k < nodes.length; k++){
                if(k == i){
                    continue;
                }else{
                    exists = false;
                    for(let e = 0; e < ogEdges.length; e++){ // проверяем, что ребра нет в исходном графе
                        if((ogEdges[e].from == nodes[i].id & ogEdges[e].to == nodes[k].id) || (ogEdges[e].to == nodes[i].id & ogEdges[e].from == nodes[k].id)){
                            exists = true;
                        }
                    }
                    for(let e = 0; e < edges.length; e++){  // проверяем, что ребро не дублируется
                        if((edges[e].from == nodes[i].id & edges[e].to == nodes[k].id) || (edges[e].from == nodes[k].id & edges[e].to == nodes[i].id)){
                            exists = true;
                        }                  
                    }
                    if(exists){
                        continue;
                    }else{
                        edges.push({from: nodes[i].id, to: nodes[k].id, id: edgesId++})
                    }
                }
            }
        }
        return { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
        }
      var data2 = compGraph(data);
      // алгоритм Брона-Кербоша
      function nodeIds(network){
        ids = [];
        network.body.data.nodes.get().forEach((i) => ids.push(i.id));
        return ids;
      }
      function BK(N, R, P, X){
        if(P.length == 0 && X.length == 0){
          console.log("Clique " + R);
        }
        for(let v of P){
          NB = N.getConnectedNodes(v)
          BK(N, _.union(R, [v]), _.intersection(P, NB), _.intersection(X, NB));
          P = _.without(P, v);
          X = _.union(X, [v]);
        }
      }

      function destroy() {
        if (network1 !== null) {
          network1.destroy();
          network1 = null;
        }
      }

      function draw() {
        destroy();
        console.log(data)

        var options1 = {
          locales:
          custom_locale = {
            "en":
            {edit: 'Редактировать',
            del: 'Удалить выбранное',
            back: 'Назад',
            addNode: 'Добавить вершину',
            addEdge: 'Добавить ребро',
            editNode: 'Редактировать вершину',
            editEdge: 'Редактировать ребро',
            addDescription: 'Кликните в свободное место, чтобы добавить новую вершину.',
            edgeDescription: 'Кликните на вершину и протяните ребро к другой вершине, чтобы соединить их.',
            editEdgeDescription: 'Click on the control points and drag them to a node to connect to it.', // кластеры не используются
            createEdgeError: 'Cannot link edges to a cluster.',
            deleteClusterError: 'Clusters cannot be deleted.',
            editClusterError: 'Clusters cannot be edited.'}
          },
          locale: "en",
          interaction: { keyboard: true },
          manipulation: {
            addNode: function (nodeData,callback) {
              lastNodeId++;
              nodeData.id = lastNodeId;
              nodeData.label = String(lastNodeId);
              callback(nodeData);
              network2.setData(compGraph(network1.body.data));

            },
            addEdge: function (data, callback) {
              if (data.from == data.to) { // петли делать нельзя
                  callback(null);
              } else{
                    callback(data);
                    network2.setData(compGraph(network1.body.data));
                  }
                },
            deleteEdge: function (data, callback){
              callback(data);
              network2.setData(compGraph(network1.body.data));
            },
            deleteNode: function (data, callback){
              callback(data);
              network2.setData(compGraph(network1.body.data));
            },
          }
        };
        var options2 = {
          locale: "ru",
          interaction: { keyboard: true },
          manipulation: { enabled: false },
          nodes: { color: "#C2FC97" }
        };
        network1 = new vis.Network(document.getElementById("mynetwork1"), data, options1);
        network2 = new vis.Network(document.getElementById("mynetwork2"), data2, options2);
        console.log(network1)
      }

      function init() {
        draw();
        network1.on("selectNode", function (params){
            network2.selectNodes(params.nodes);
        });
        network1.on("deselectNode", function (params){
            network2.unselectAll();
        })
      }
      function exportNetwork(){
        nodes = network1.body.data.nodes.get();
        edges = network1.body.data.edges.get();
        data = {nodes: nodes, edges: edges};
        document.getElementById("input_output").value = JSON.stringify(data);
      }
      function importNetwork(){
        data = JSON.parse(document.getElementById("input_output").value);
        network1.setData(data);
        network2.setData(compGraph(network1.body.data))
      }
    </script>
  </head>

  <body onload="init();">
    <br />
    <div id="mynetwork1"></div>
    <div id="mynetwork2"></div>
    <div>
      <textarea id="input_output"></textarea>
      <input
        type="button"
        id="import_button"
        onclick="importNetwork()"
        value="import"
      />
      <input
        type="button"
        id="export_button"
        onclick="exportNetwork()"
        value="export"
      />
      <input
        type="button"
        id="BK_button"
        onclick="console.log(BK(network1, [], nodeIds(network1), []))"
        value="BK"
      />
    </div>
  </body>
</html>